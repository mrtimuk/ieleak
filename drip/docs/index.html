<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:dt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<title>Drip, Windows Developer Power Tools</title>
</head>

<body lang=EN-US link=red vlink=red style='tab-interval:.5in'>
<div link="red" vlink="red" lang="EN-US">
	<div>
		<p>
			22</p>
		<p>
			Web Utilities / [Subsection]</p>
		<p>
			<strong><span style="font-size: 14pt; color: red;">Eliminate Memory Leaks in Internet Explorer</span></strong></p>
		<p>
			In the past, web pages have typically used small amounts of memory. This has changed
			with the recent popularity of dynamic web applications, especially AJAX-enabled
			ones. Web pages sometimes use lots of memory while they are open. Even worse, if
			specific care is not taken, they will continue using that memory after the user
			has left the page.</p>
		<p>
			A “memory leak” is a programmer term for a situation when memory has
			been allocated by a program, but it is never deallocated. It is not a critical programming
			error as it usually does not crash the program. Nevertheless it is annoying because
			the amount of available physical memory is limited. Using too much memory will cause
			the computer to run more slowly as the operating system starts swapping memory to
			the hard drive. In some situations, using too much memory will even cause the program
			to crash.</p>
		<p>
			The Internet Explorer browser has a peculiarity that can cause it to leak memory.
			It parses the HTML document and creates a tree of document object model (DOM) objects
			all of which are exposed via a set of Component Object Model (COM) interfaces. Those
			interfaces are used to access and modify the document from JavaScript and other
			languages. The COM system that is built in every modern version of the Windows operating
			system uses reference-count garbage collection: all objects references are counted,
			and an object’s memory is released when its reference count reaches zero.
			But this does not work if there are circular references between objects. Two objects
			might hold references to each other and neither one of them will be garbage collected,
			since their reference counts will never reach zero. Native JavaScript objects such
			as String, Array, or user-defined objects do not rely on COM for their memory management
			and do not suffer from the above limitation. Crossing the COM boundary and accessing
			the parsed DOM objects, however, may create circular references between DOM objects
			or DOM objects and JavaScript objects. This can happen on your DHTML-rich page and
			it can degrade the performance of your web application.</p>
		<p>
			Checking your application’s memory consumption and fighting leaks proactively
			and on a regular basis will guarantee you optimal performance and no unhappy users.
			Drip is an excellent tool that can help you do just that. It has been originally
			developed by Joel Webber and is now maintained and developed by Matthias Miller.
			Drip allows you to open your web application and work with it from within the program.
			It keeps track of DOM objects that are created and used, and displays a list of
			the objects that have not been freed and will keep taking up precious memory.</p>
		<p>
			&nbsp;</p>
		<table style="border: medium none ; margin-left: 0.2in; border-collapse: collapse;" border="1" cellpadding="0" cellspacing="0">
			<tbody><tr>
				<td style="border: 1pt solid windowtext; padding: 0in 5.4pt; width: 2.5in;" valign="top" width="240">
					<p>
						Tool: Drip</p>
				</td>
				<td style="border-style: solid solid solid none; border-color: windowtext windowtext windowtext -moz-use-text-color; border-width: 1pt 1pt 1pt medium; padding: 0in 5.4pt; width: 224.8pt;" valign="top" width="300">
					<p>
						Version: 0.4</p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						Homepage: <a href="http://www.outofhanwell.com/ieleak/" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">http://www.outofhanwell.com<wbr>/ieleak/</a></p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						Power Tools Page:</p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						Summary: Easy to use memory leak detector that keeps track of DOM objects used by
						Internet Explorer. The program allows you to inspect browser memory usage and detect
						leaking objects.</p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						License Type: BSD</p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						Resources: The homepage hosts a wiki that contains most of the documentation resources.
						The wiki has a section with references to memory leak detection and prevention articles
						on the web.</p>
				</td>
			</tr>
			<tr>
				<td colspan="2" style="border-style: none solid solid; border-color: -moz-use-text-color windowtext windowtext; border-width: medium 1pt 1pt; padding: 0in 5.4pt; width: 404.8pt;" valign="top" width="540">
					<p>
						Related Tools: None</p>
				</td>
			</tr>
		</tbody></table>
		<p>
			&nbsp;</p>
		<h3>
			Requirements</h3>
		<p>
			Drip runs on 32-bit Windows platforms: Windows 95/98, Windows NT, Windows 2000,
			and Windows XP. It will work with both standalone HTML files stored on your hard
			drive and URL’s of live sites somewhere on the web.</p>
		<h3>
			Setup</h3>
		<p>
			No complex setup is required. Drip is a single executable file, which you can download
			from its homepage. The C++ source code is available too: you can compile it with
			Visual Studio .NET 2003 or later.</p>
		<h3>
			Hunting for Memory Leaks</h3>
		<p>
			Starting Drip will present you with the main screen as seen on <a href="WDPT%20Ch22%20Drip_files/image001.png" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">
				<span>Figure 22-1</span></a>.</p>
		<div>
			<p>
				<img src="WDPT%20Ch22%20Drip_files/image002.jpg" border="0" height="279" width="479"></p>
			<p>
				Figure <span><span>22</span></span>-<span><span>1</span></span>. Drip main screen</p>
		</div>
		<p>
			Any memory leak measurement will require navigating to a web page. Type or paste
			the address of the page and click “Go” to load the page. The page will
			be loaded and will be displayed in the central browser area. The page will be fully
			operational and you will have to exercise any actions that will invoke the script
			code that you want to check for leaks. <a href="WDPT%20Ch22%20Drip_files/image003.png" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)"><span>
				Figure 22-2</span></a> shows a sample page.</p>
		<div>
			<p>
				<img src="WDPT%20Ch22%20Drip_files/image004.jpg" border="0" height="279" width="479"></p>
			<p>
				Figure <span><span>22</span></span>-<span><span>2</span></span>. A sample page running
				inside Drip</p>
		</div>
		<p>
			Watch the memory usage field as you click around the page. The field provides additional
			information about memory allocations done by the browser.</p>
		<p>
			Do not worry about complex sites that have several documents and pages. Drip will
			keep track of additional browser documents that are loaded in frames and iframes
			(<span><span>&lt;iframe&gt;</span></span> elements). Additionally
			it will detect new windows opened from the original page. The only downside is that
			newly opened windows cannot be automatically refreshed by the tool. Probably the
			best way to check documents opened in new windows is to navigate directly to their
			URL and check the memory usage there.</p>
		<h3>
			Identifying Leaked Objects</h3>
		<p>
			After you are done working with your page you will have to click the “Check
			Leaks” button. It will clear the currently loaded page, force garbage collection
			for unused objects, and will display a dialog with information about the leaks.
			The dialog will display the URL of the document that contained the object, the number
			of references to that object, the tag name, and the ID of the element. That information
			is tremendously helpful in identifying the offending elements, so that you can break
			the circular references and reclaim your memory. <a href="WDPT%20Ch22%20Drip_files/image005.png" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">
				<span>Figure 22-3</span></a> shows that our page leaks two <span>
					<span>&lt;a&gt;</span></span> elements:</p>
		<div>
			<p>
				<img src="WDPT%20Ch22%20Drip_files/image006.jpg" border="0" height="282" width="480"></p>
			<p>
				Figure <span><span>22</span></span>-<span><span>3</span></span>. Two hyperlinks
				that leak memory</p>
		</div>
		<p>
			What if your elements do not have an ID set or you have many elements that look
			alike? You can get more information about a leaked element by selecting it and clicking
			the “Properties” button. The Properties dialog will open and it will
			display all the properties of that object. The best way to identify the object is
			to look at the <span><span>innerHTML</span></span> and <span><span>outerHTML</span></span> properties – they
			contain the markup that is rendered on the page and can provide important clues
			about the leakage.</p>
		<div>
			<p>
				<img src="WDPT%20Ch22%20Drip_files/image008.jpg" border="0" height="412" width="480"></p>
			<p>
				Figure <span><span>22</span></span>-<span><span>4</span></span>. Properties like
				outerHTML help find unknown elements</p>
		</div>
		<h3>
			Watching Memory Usage over Time</h3>
		<p>
			Probably the best way to detect problems with your application’s memory usage
			is to monitor the amount of memory used as repetitive tasks are performed. Drip
			helps in doing this with its “Auto-Refresh” feature. Clicking the button
			will start refreshing the page, keeping track of the memory used after each refresh.
			The list box on the right hand side contains the memory measurement samples. An
			application that leaks will take up more and more memory after each request and
			you can easily see that from the list. Optimized applications will keep the memory
			size constant with small fluctuations that might be caused by the browser’s
			inner workings. <a href="WDPT%20Ch22%20Drip_files/image009.png" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)"><span>Figure 22-5</span></a>
			shows a leaky application whose memory usage grows steadily.</p>
		<div>
			<p>
				<img src="WDPT%20Ch22%20Drip_files/image010.jpg" border="0" height="279" width="479"></p>
			<p>
				Figure <span><span>22</span></span>-<span><span>5</span></span>. Losing approximately
				7KB per request</p>
		</div>
		<p>
			The automatic page reloading covers the most common scenario: a web page that attaches
			script code to some elements’ events when the document loads. Some applications
			do way more than that: menus and lists are built dynamically; new form elements
			are created so that users can enter more data without waiting for an additional
			roundtrip to the server; animation effects are implemented by moving elements around
			the page. In order to test such complex scenarios for leaks you will either have
			to manually exercise them by triggering the actions or you can add a script that
			triggers them in the <span><span>window.onload</span></span>
			event handler for testing purposes. The code in that handler will execute every
			time Drip refreshes the page.</p>
		<h4>
			Typical Leak Scenarios and Ways to Resolve Them</h4>
		<p>
			The only way for an element to leak is to create a circular reference to it. The
			reference can be as simple as creating a new <span><span>expando</span></span>
			property that points to itself:</p>
		<div style="border-style: none none none solid; border-color: -moz-use-text-color -moz-use-text-color -moz-use-text-color windowtext; border-width: medium medium medium 1pt; padding: 0in 0in 0in 2pt; margin-left: 0.25in;">
			<p style="margin: 0in 0in 0.0001pt;">
				linkElement.circularRef = linkElement;</p>
		</div>
		<p>
			You can have a more complicated scenario where an object references other objects
			which in turn reference it back.</p>
		<p>
			The most common way to create a circular reference could be the hardest to spot
			as there are no variables or properties declared that contain reference to objects.
			It usually happens when people create new functions and attach them as event handlers.
			Functions in JavaScript reference all the variables that are visible at the place
			of the function declaration. That is why they are also called closures – they
			encapsulate or close over the variables, so that they can be used from the function’s
			code, whenever it is called. Here is an example of a function that attaches two
			<span><span>onclick</span></span> event handlers to links
			in a tab control:</p>
		<div style="border-style: none none none solid; border-color: -moz-use-text-color -moz-use-text-color -moz-use-text-color windowtext; border-width: medium medium medium 1pt; padding: 0in 0in 0in 2pt; margin-left: 0.25in;">
			<p style="margin: 0in 0in 0.0001pt;">
				function InitializeTabs()</p>
			<p style="margin: 0in 0in 0.0001pt;">
				{</p>
			<p style="margin: 0in 0in 0.0001pt;">
				var news = document.getElementById("newsLink");</p>
			<p style="margin: 0in 0in 0.0001pt;">
				news.tabId = "news";</p>
			<p style="margin: 0in 0in 0.0001pt;">
				var pictures = document.getElementById("picturesLink");</p>
			<p style="margin: 0in 0in 0.0001pt;">
				pictures.tabId = "pictures";</p>
			<p style="margin: 0in 0in 0.0001pt;">
			</p>
			<p style="margin: 0in 0in 0.0001pt;">
				function TabLinkClick()</p>
			<p style="margin: 0in 0in 0.0001pt;">
				{</p>
			<p style="margin: 0in 0in 0.0001pt;">
				var visibleTab = document.getElementById(this.tabId);</p>
			<p style="margin: 0in 0in 0.0001pt;">
				var tabContainer = document.getElementById("tabs");</p>
			<p style="margin: 0in 0in 0.0001pt;">
				var tabs = tabContainer.getElementsByTagNa<wbr>me("div");</p>
			<p style="margin: 0in 0in 0.0001pt;">
			</p>
			<p style="margin: 0in 0in 0.0001pt;">
				//hide all tabs</p>
			<p style="margin: 0in 0in 0.0001pt;">
				for (var i = 0; i &lt; tabs.length; i++)</p>
			<p style="margin: 0in 0in 0.0001pt;">
				tabs[i].style.display = "none";</p>
			<p style="margin: 0in 0in 0.0001pt;">
			</p>
			<p style="margin: 0in 0in 0.0001pt;">
				//show the selected tab</p>
			<p style="margin: 0in 0in 0.0001pt;">
				visibleTab.style.display = "block";</p>
			<p style="margin: 0in 0in 0.0001pt;">
				}</p>
			<p style="margin: 0in 0in 0.0001pt;">
				&nbsp;</p>
			<p style="margin: 0in 0in 0.0001pt;">
				news.onclick = TabLinkClick;</p>
			<p style="margin: 0in 0in 0.0001pt;">
				pictures.onclick = TabLinkClick;</p>
			<p style="margin: 0in 0in 0.0001pt;">
				}</p>
		</div>
		<p>
			The <span><span>TabLinkClick</span></span> function is declared
			inside <span><span>InitializeTabs</span></span>. It “sees”
			the two variables (<span><span>news</span></span> and <span><span>pictures</span></span>) that contain references
			to the links in the document and encapsulates them, so that they are visible to
			the function code. The function is then attached as an <span>
				<span>onclick</span></span> event handler to the two links. It does not matter
			that <span><span>TabLinkClick</span></span>’s code
			does not use <span><span>news</span></span> or <span>
				<span>pictures</span></span> in any way – references to them are still
			kept by the script engine. Here lies the circular reference: each link keeps a reference
			to <span><span>TabLinkClick</span></span> as its <span>
				<span>onclick</span></span> event handler and <span><span>TabLinkClick</span></span>
			keeps an internal reference to the link.</p>
		<p>
			There are three possible solutions to that problem:</p>
		<p>
			<span style="font-family: Symbol;"><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span>
			Move the TabLinkClick function definition outside InitializeTabs. It will not see
			the link variables and will not keep references to them thus avoiding the problem
			altogether.</p>
		<p>
			<span style="font-family: Symbol;"><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span>
			Set <span><span>news</span></span> and <span>
				<span>pictures</span></span> to <span><span>null</span></span>
			after you have assigned the event handlers. This breaks the references to the link
			variables.</p>
		<p>
			<span style="font-family: Symbol;"><span>·<span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span></span>
			Detach the event handlers when you are done. This can be performed just before the
			page is unloaded in the <span><span>window.onunload</span></span>
			event handler or when the tabbed navigation is deterministically destroyed from
			code. Some object-oriented JavaScript libraries define a <span>
				<span>Dispose()</span></span> method for each object that takes care to release
			all DOM object references, detach all event handlers and call the appropriate <span><span>Dispose()</span></span> methods of all its child
			objects.</p>
		<h4>
			Drip Limitations</h4>
		<p>
			Drip works by intercepting DOM element creation. Each new element is being recorded,
			and later checked if it has been properly released. The challenge of writing such
			a tool lies in intercepting the various ways a script can create new DOM elements.
			Drip intercepts most of them: <span><span>document.createElement(…)</span></span>,
			<span><span>element.cloneNode()</span></span>, <span>
				<span>element.innerHTML = “&lt;p&gt;test&lt;/p&gt;”</span></span>,
			etc. The only currently known way to create elements that Drip does not intercept
			is setting the <span><span>outerHTML</span></span> property
			of an element. For example, you can create a new <span><span>
				&lt;div&gt;</span></span> element by setting an element’s <span>
					<span>outerHTML</span></span> property, create a circular reference, and
			it will leak, going undetected. The only sound advice on dealing with that at the
			moment is to avoid using <span><span>outerHTML</span></span>
			altogether. Another reason to do so is that the property is not W3C standards compliant
			and it works in Internet Explorer only.</p>
		<p>
			The recent AJAX popularity has changed the rules of the memory management game.
			AJAX is an acronym for <strong>A</strong>synchronous <strong>J</strong>avaScript
			<strong>A</strong>nd <strong>X</strong>ML – it is a way for a web application
			to initiate an HTTP request from script, retrieve data, and update only a portion
			of the page without having to submit the entire form contents and force the user
			to reload the entire document. The lower latency and increased responsiveness of
			this development approach has given birth to applications that users can use for
			hours without navigating away from a page. Google’s GMail service is an example
			of such an application. This style of development poses new challenges to memory
			management. Applications can use up more and more memory without creating circular
			references just by regularly requesting new content from the server and updating
			the current document. New DOM elements created after an AJAX request make the current
			document more and more complex. They may not technically leak, and the memory can
			be reclaimed after the page reloads, but this may not happen for quite some time.
			Soon the user finds herself in a situation where the browser takes up several hundred
			megabytes of memory for no obvious reason. Reloading the page will reclaim the memory,
			but the whole point of AJAX is to avoid doing that.</p>
		<h3>
			Summary</h3>
		<p>
			Currently the main resource for Drip-related news and information is the tool homepage
			and Matthias Miller’s weblog at <span><a href="http://outofhanwell.com/blog/" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">
				http://outofhanwell.com/blog/</a></span>. The homepage contains links to articles
			that explain the memory leak problem in greater detail and provide specific solutions
			and code samples. The SourceForge project page at <span><a href="http://sourceforge.net/projects/ieleak" target="_blank" onclick="return top.js.OpenExtLink(window,event,this)">http://sourceforge.net/projects<wbr>/ieleak</a></span>
			provides forums for support requests, feature suggestions and various community
			discussions.</p>
		<p>
			Drip provides enormous help to web developers that create complex, JavaScript-rich
			websites by helping resolve memory-related problems. Leaks have been a problem with
			Internet Explorer for a lot of time and will continue to be a problem even with
			the next version of the browser – Internet Explorer 7, as it will continue
			to use the COM-based object model. The browser will likely remain highly popular,
			so fighting memory leaks will continue to be an important part of a web developer’s
			skill set.</p>
	</div>
</div>

</body>

</html>
